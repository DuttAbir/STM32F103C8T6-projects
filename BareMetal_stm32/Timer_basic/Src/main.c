/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>

/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/

#include "stm32f1xx.h"

#define HSE_VALUE 8000000U
#define PLL_MULT 4

void sys_clk(void) {
    // Enable HSE
    RCC->CR |= RCC_CR_HSEON;
    //wait longer for HSE ready.
    uint32_t timeout = 0xFFFFF; // Increase timeout
    while (!(RCC->CR & RCC_CR_HSERDY) && timeout--);

    //check if HSE ready.
    if(timeout == 0){
        //HSE failed to start.
        return; //exit the function.
    }

    // Configure Flash latency
    FLASH->ACR |= FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY_1;

    // Configure PLL
    RCC->CFGR |= RCC_CFGR_PLLSRC;
    RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;
    RCC->CFGR |= (PLL_MULT << RCC_CFGR_PLLMULL_Pos);

    // Enable PLL
    RCC->CR |= RCC_CR_PLLON;
    timeout = 0xFFFFF;
    while (!(RCC->CR & RCC_CR_PLLRDY) && timeout--);

    if(timeout == 0){
        //PLL failed to lock.
        return; //exit function.
    }

    // Select PLL as system clock
    RCC->CFGR |= RCC_CFGR_SWS_PLL;
    timeout = 0xFFFFF;
    while (!(RCC->CFGR & RCC_CFGR_SWS_PLL) && timeout--);

    if(timeout == 0){
        //PLL switch failed.
        return; //exit function.
    }
}

void Gpio_conf(){
	RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
		GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);

		GPIOC->CRH |= (GPIO_CRH_MODE13_1 | GPIO_CRH_MODE13_0);

		GPIOC->CRH |= ~(GPIO_CRH_CNF13_1 | GPIO_CRH_CNF13_0);
}

// Timer Frequency (TF) = bus Clock (FsysClock) / (Prescalor(TIM2PSC) + 1)

// Timer time period (TTP) = 1 / TF

// Time delay by timer = TTP * Timer auto reload Register(TIM2ARR)

//System clock = 32MHz, TIM2PSC = 32, TF = 1MHz

// TTP = 1us

// TIM2RRR = 0xffff

void timer_initilize(){
	//make sure the timer counter is off
	TIM2->CR1 &= ~(TIM_CR1_CEN);
	TIM2->SR &= ~(TIM_SR_UIF);

	//reset the timer2 bus
	RCC->APB1RSTR |= (RCC_APB1RSTR_TIM2RST);
	RCC->APB1RSTR &= ~(RCC_APB1RSTR_TIM2RST);

	//enable timer2 peripheral clock
	RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;

	//enable the update generation
	TIM2->EGR |= TIM_EGR_UG;

	/************Example*******************/

	TIM2->PSC = 32;

	TIM2->ARR = 0xffff;

	TIM2->CR1 |= TIM_CR1_CEN;
	//while(!(TIM2->SR & (1<<TIM_SR_UIF)));

}

/* 1us = 1 count , 1ms  = 1000us, 1s = 1000ms */

void delay_us(uint16_t us){
	TIM2->CNT = 0;
	while(TIM2->CNT < us);
}

void delay_ms(uint16_t ms){
	for(uint16_t i = 0; i<ms; i++)
		delay_us(1000);
}

void delay_sec(uint16_t sec){
	for(uint16_t i = 0; i<sec; i++)
		delay_ms(1000);
}

unsigned long int dl;

int main(void)
{
	sys_clk();

	Gpio_conf();

	timer_initilize();

    /* Loop forever */
	while(1){

		GPIOC->ODR ^= (GPIO_ODR_ODR13);
		delay_sec(1);
	}
}
