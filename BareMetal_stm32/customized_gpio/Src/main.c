/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
/*
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
*/



#include "stm32f1xx.h"

#define HSE_VALUE 8000000U
#define PLL_MULT 4

void sys_clk(void) {
    // Enable HSE
    RCC->CR |= RCC_CR_HSEON;
    //wait longer for HSE ready.
    uint32_t timeout = 0xFFFFF; // Increase timeout
    while (!(RCC->CR & RCC_CR_HSERDY) && timeout--);

    //check if HSE ready.
    if(timeout == 0){
        //HSE failed to start.
        return; //exit the function.
    }

    // Configure Flash latency
    FLASH->ACR |= FLASH_ACR_PRFTBE | FLASH_ACR_LATENCY_1;

    // Configure PLL
    RCC->CFGR |= RCC_CFGR_PLLSRC;
    RCC->CFGR |= RCC_CFGR_PLLXTPRE_HSE;
    RCC->CFGR |= (PLL_MULT << RCC_CFGR_PLLMULL_Pos);

    // Enable PLL
    RCC->CR |= RCC_CR_PLLON;
    timeout = 0xFFFFF;
    while (!(RCC->CR & RCC_CR_PLLRDY) && timeout--);

    if(timeout == 0){
        //PLL failed to lock.
        return; //exit function.
    }

    // Select PLL as system clock
    RCC->CFGR |= RCC_CFGR_SWS_PLL;
    timeout = 0xFFFFF;
    while (!(RCC->CFGR & RCC_CFGR_SWS_PLL) && timeout--);

    if(timeout == 0){
        //PLL switch failed.
        return; //exit function.
    }
}

void delay(uint32_t count) {
    for (uint32_t i = 0; i < count; i++);
}

//... main function...

int main(void) {
    sys_clk(); // Configure system clock to HSI

    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;

    GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13);
    GPIOC->CRH |= (GPIO_CRH_MODE13_1 | GPIO_CRH_MODE13_0);
    GPIOC->CRH &= ~(GPIO_CRH_CNF13_1 | GPIO_CRH_CNF13_0);

    while (1) {
        GPIOC->ODR |= GPIO_ODR_ODR13;
        delay(800000);
        GPIOC->ODR &= ~GPIO_ODR_ODR13;
        delay(800000);
    }
}

/******************************* With default clock settings*******************************/




//#include "stm32f1xx.h"
//
//int main(void) {
//    // Enable clock for GPIOC
//    RCC->APB2ENR |= RCC_APB2ENR_IOPCEN;
//
//    // Configure PC13 as output
//    GPIOC->CRH &= ~(GPIO_CRH_MODE13 | GPIO_CRH_CNF13); // Clear mode and config
//    GPIOC->CRH |= (GPIO_CRH_MODE13_1 | GPIO_CRH_MODE13_0); // Output mode, 50MHz
//    GPIOC->CRH &= ~(GPIO_CRH_CNF13_1 | GPIO_CRH_CNF13_0); // General purpose output push-pull
//
//    // Simple delay function
//    volatile uint32_t delay_count; // volatile to prevent compiler optimization issues
//
//    while (1) {
//        GPIOC->ODR |= GPIO_ODR_ODR13; // Turn LED on
//        delay_count = 800000; // Adjust delay as needed
//        while (delay_count--) {}
//
//        GPIOC->ODR &= ~GPIO_ODR_ODR13; // Turn LED off
//        delay_count = 800000; // Adjust delay as needed
//        while (delay_count--) {}
//    }
//}
